# ============================================
# 必要なライブラリのインポート
# ============================================

# sys: システム関連の機能を使うためのライブラリ（今回は使っていませんが、将来の拡張用）
import sys

# time: 時間に関する機能を使うためのライブラリ
# sleep()関数でプログラムを一時停止できます
import time

# smartcard.System.readers: NFCリーダーを検出するための関数
# パソコンに接続されているNFCリーダー（ACR122Uなど）を見つけます
from smartcard.System import readers

# smartcard.util: スマートカード関連の便利な関数
# toHexString: バイトデータを16進数の文字列に変換する関数
# toBytes: 文字列をバイトデータに変換する関数（今回は使っていません）
from smartcard.util import toHexString, toBytes

# ============================================
# NTAG (NFC Forum Type 2) 専用コマンドの定義
# ============================================

# NFCカードには「NTAG」という種類があります
# NTAGカードは、データを「ページ」という単位で管理しています
# 1ページ = 4バイト（32ビット）のデータを保存できます

# --- 1. IDm (シリアルナンバー) 取得コマンド ---
# IDm: カードの固有ID（シリアルナンバー）のこと
# このコマンドを送ると、カードのIDが返ってきます
# [0xFF, 0xCA, 0x00, 0x00, 0x00] は、リーダーに送る命令のバイト列です
CMD_GET_IDM = [0xFF, 0xCA, 0x00, 0x00, 0x00]

# --- 2. ページ読み取りコマンド ---
# カードの特定のページ（場所）からデータを読み取るコマンド
# [Class, INS, P1(0x00), P2(ページ番号), Le(バイト数=4)]
# Class: コマンドのクラス（0xFFは拡張コマンド）
# INS: 命令コード（0xB0は読み取り命令）
# P1: パラメータ1（通常は0x00）
# P2: パラメータ2（読み取るページ番号を指定）
# Le: 読み取るバイト数（4バイト = 1ページ分）

# 読み取るページ番号を指定（0x04は16進数で4、つまり4ページ目）
PAGE_TO_READ = 0x04  # 4ページ目を読み取る

# 読み取りコマンドを作成
# [0xFF, 0xB0, 0x00, ページ番号, 0x04] = 「4ページ目から4バイト読み取って」
CMD_READ_PAGE = [0xFF, 0xB0, 0x00, PAGE_TO_READ, 0x04]

# --- 3. ページ書き込みコマンド ---
# カードの特定のページ（場所）にデータを書き込むコマンド
# [Class, INS, P1(0x00), P2(ページ番号), Lc(バイト数=4), データ(4バイト)]
# Class: コマンドのクラス（0xFFは拡張コマンド）
# INS: 命令コード（0xD6は書き込み命令）
# P1: パラメータ1（通常は0x00）
# P2: パラメータ2（書き込むページ番号を指定）
# Lc: 書き込むバイト数（4バイト = 1ページ分）
# その後ろに、実際に書き込むデータ（4バイト）を続けます

# 書き込むページ番号を指定（0x04は16進数で4、つまり4ページ目）
PAGE_TO_WRITE = 0x04  # 4ページ目に書き込む

# 書き込むデータ（4バイト）
# [0x01, 0x02, 0x03, 0x04] は16進数で、10進数では [1, 2, 3, 4] です
# 例: ステータス情報やユーザーIDなどを保存できます
DATA_TO_WRITE = [0x01, 0x02, 0x03, 0x04]

# 書き込みコマンドを作成
# [0xFF, 0xD6, 0x00, 0x04, 0x04] + [0x01, 0x02, 0x03, 0x04]
# = 「4ページ目に [0x01, 0x02, 0x03, 0x04] を書き込んで」
CMD_WRITE_PAGE = [0xFF, 0xD6, 0x00, PAGE_TO_WRITE, 0x04] + DATA_TO_WRITE

# ============================================
# 全ページ読み取り関数
# ============================================

def read_all_pages(connection):
    """
    NTAGカードの全ページ（0〜39）を読み込んで表示する関数
    
    Args:
        connection: カードリーダーとの接続オブジェクト
    """
    print("\n--- 全ページ読み取り開始 ---")
    print("（カードの0〜39ページの内容をすべて表示します）")
    
    # 0ページから39ページまでループ
    for page in range(40):
        # ページ読み取りコマンドを作成
        # [0xFF, 0xB0, 0x00, ページ番号, 0x04]
        cmd = [0xFF, 0xB0, 0x00, page, 0x04]
        
        # コマンドを送信して応答を受信
        data, sw1, sw2 = connection.transmit(cmd)
        
        # 読み取りが成功したか確認
        if sw1 == 0x90 and sw2 == 0x00:
            # 成功した場合: ページ番号と読み取ったデータを表示
            # {page:02}: ページ番号を2桁で表示（例: 4 → 04）
            print(f"  ページ {page:02}: {toHexString(data)}")
        else:
            # 失敗した場合: エラーメッセージを表示してループを終了
            print(f"  ページ {page:02}: 読み取りエラー - SW={sw1:02X} {sw2:02X}")
            break  # エラーが発生したらループを中断
            
    print("--- 全ページ読み取り完了 ---\n")

# ============================================
# メイン関数: NTAGカードの読み書きテスト
# ============================================

def test_ntag_rw():
    """
    NTAGカードの読み書きをテストする関数
    
    この関数は以下のことを行います：
    1. NFCリーダーを検出
    2. カードがタッチされるのを待つ
    3. カードのIDを読み取る
    4. データを書き込む
    5. 書き込んだデータを読み取って確認する
    """
    
    # try-except: エラーが発生した場合にプログラムが止まらないようにする
    try:
        # パソコンに接続されているNFCリーダーを検出
        # readers()関数が、接続されているリーダーのリストを返します
        r = readers()
        
        # リーダーが見つからなかった場合の処理
        if not r:
            print("エラー: リーダー(ACR122U)が見つかりません。")
            print("→ リーダーがUSBポートに正しく接続されているか確認してください。")
            return  # 関数を終了
        
        # 見つかったリーダーのうち、最初の1つを使う
        # r[0] は、リストの最初の要素（最初に見つかったリーダー）を取得
        reader = r[0]
        print(f"リーダー検出: {reader}")
        print("NTAGカードをリーダーにタッチしてください...")
        print("（カードをリーダーの上に置いてください）")
        
        # リーダーとの接続オブジェクトを作成
        # この接続オブジェクトを使って、カードと通信します
        connection = reader.createConnection()
        
        # 無限ループ: カードがタッチされるたびに処理を繰り返す
        # while True: は、永遠に繰り返すという意味です
        while True:
            try:
                # カードに接続を試みる
                # カードがリーダーにタッチされていないと、ここでエラーになります
                connection.connect()
                print("\n--- カード検出！ ---")
                print("（カードがリーダーに正しく置かれました）")
                
                # ============================================
                # ステップ1: IDm（カードのID）を読み取る
                # ============================================
                
                # transmit()関数: コマンドをカードに送信し、応答を受け取る
                # CMD_GET_IDM: 先ほど定義した「IDを取得するコマンド」
                # 戻り値:
                #   - data: カードから返ってきたデータ（IDのバイト列）
                #   - sw1, sw2: ステータスワード（コマンドが成功したかどうかを示す）
                data, sw1, sw2 = connection.transmit(CMD_GET_IDM)
                
                # ステータスワードの確認
                # sw1 == 0x90 かつ sw2 == 0x00 の場合、コマンドが成功したことを意味します
                if sw1 == 0x90 and sw2 == 0x00:
                    # 成功した場合: データを16進数の文字列に変換して表示
                    # toHexString(): バイト配列を16進数の文字列に変換（例: [0x12, 0x34] → "12 34"）
                    print(f"  [成功] IDm: {toHexString(data)}")
                    print(f"  → カードのID（シリアルナンバー）を取得しました")
                else:
                    # 失敗した場合: エラーメッセージを表示
                    # {sw1:02X} は、sw1を2桁の16進数で表示するという意味
                    print(f"  [失敗] IDm読み取りエラー: SW={sw1:02X} {sw2:02X}")
                    print(f"  → カードが正しく認識されていない可能性があります")
                    continue  # エラーならループの最初に戻る（次の処理をスキップ）

                # ============================================
                # ステップ2: データをカードに書き込む (コメントアウト)
                # ============================================
                
                # print(f"  書き込み中... (ページ {PAGE_TO_WRITE} に {toHexString(DATA_TO_WRITE)} を書き込み)")
                # print(f"  → カードの{PAGE_TO_WRITE}ページ目にデータを書き込んでいます...")
                
                # data, sw1, sw2 = connection.transmit(CMD_WRITE_PAGE)
                
                # if sw1 == 0x90 and sw2 == 0x00:
                #     print("  [成功] 書き込み完了！")
                #     print(f"  → カードにデータが正しく書き込まれました")
                # else:
                #     print(f"  [失敗] 書き込みエラー: SW={sw1:02X} {sw2:02X}")
                #     print(f"  → カードが書き込み可能か確認してください（一部のカードは読み取り専用です）")
                #     continue
                
                # time.sleep(0.1)

                # ============================================
                # ステップ3: 書き込んだデータを読み取って確認する (コメントアウト)
                # ============================================
                
                # print(f"  読み取り中... (ページ {PAGE_TO_READ} を確認)")
                # print(f"  → 書き込んだデータが正しく保存されているか確認します...")
                
                # data, sw1, sw2 = connection.transmit(CMD_READ_PAGE)
                
                # if sw1 == 0x90 and sw2 == 0x00:
                #     print(f"  [成功] 読み取りデータ: {toHexString(data)}")
                    
                #     if data == DATA_TO_WRITE:
                #         print("  [検証OK] 書き込んだデータと一致しました！")
                #         print(f"  → テスト成功！カードへの書き込み・読み取りが正常に動作しています")
                #     else:
                #         print("  [検証NG] 書き込んだデータと一致しません！")
                #         print(f"  → 書き込んだデータ: {toHexString(DATA_TO_WRITE)}")
                #         print(f"  → 読み取ったデータ: {toHexString(data)}")
                #         print(f"  → データが正しく書き込まれていない可能性があります")
                # else:
                #     print(f"  [失敗] 読み取りエラー: SW={sw1:02X} {sw2:02X}")
                #     print(f"  → カードが正しく認識されていない可能性があります")

                # ============================================
                # ステップ4: 全ページを読み取る
                # ============================================
                
                # 追加した関数を呼び出して、全ページの内容を表示
                read_all_pages(connection)

                # ============================================
                # 処理完了後の待機
                # ============================================
                
                print("---------------------")
                print("✅ 1回のテストが完了しました！")
                print("カードを離して、もう一度タッチしてください。")
                print("（次のテストを開始するには、カードを一度離してから再度タッチしてください）")
                
                # カードが離されるまで待機するループ
                # カードがまだリーダーの上にある間は、次の処理に進みません
                while True:
                    try:
                        # getATR(): カードがまだ存在するかチェックする関数
                        # カードが存在する場合、正常に動作します
                        # カードが離されると、エラー（例外）が発生します
                        connection.getATR()
                        
                        # 0.5秒待ってから、再度チェック
                        time.sleep(0.5)
                    except:
                        # カードが離された場合（エラーが発生した場合）
                        print("\nカードが離されました。待機中...")
                        print("（次のカードをタッチしてください）")
                        break  # 内側のループを抜ける（外側のループに戻る）
                
            except Exception as e:
                # カードがまだタッチされていない時の処理
                # connection.connect()が失敗した場合、ここに来ます
                # これは正常な動作なので、エラーメッセージは表示しません
                # 0.5秒待ってから、再度カードの検出を試みます
                time.sleep(0.5)
                # ループの最初に戻って、再度カードの検出を試みます

    except Exception as e:
        # プログラム全体で発生した致命的なエラーを処理
        # 例: リーダーが見つからない、USB接続が切れた、など
        print(f"❌ 致命的なエラーが発生しました: {e}")
        print("→ リーダーが正しく接続されているか確認してください。")
        print("→ プログラムを終了します。")

# ============================================
# プログラムのエントリーポイント（開始地点）
# ============================================

# if __name__ == "__main__": 
# このファイルが直接実行された場合のみ、以下のコードを実行します
# （他のファイルから import された場合は実行されません）
if __name__ == "__main__":
    # test_ntag_rw()関数を呼び出して、テストを開始します
    test_ntag_rw()